"""
Git integration

Manages git operations for healed selectors.
"""

from dataclasses import dataclass
from typing import List, Optional
from pathlib import Path
from datetime import datetime
import subprocess
import json


@dataclass
class GitCommitInfo:
    """Information about a healing commit"""
    commit_hash: str
    timestamp: datetime
    files_changed: List[Path]
    selectors_healed: int
    message: str


class GitIntegration:
    """
    Git operations for healing system
    """
    
    def __init__(self, repo_path: Path):
        """
        Initialize git integration
        
        Args:
            repo_path: Path to git repository root
        """
        self.repo_path = repo_path
    
    def commit_healing(
        self,
        updated_files: List[Path],
        healing_details: List[dict],
        branch_name: Optional[str] = None
    ) -> Optional[GitCommitInfo]:
        """
        Commit healed selectors to git
        
        Args:
            updated_files: List of files that were updated
            healing_details: List of healing details (old/new selectors, confidence, etc.)
            branch_name: Optional branch name (creates new branch if provided)
        
        Returns:
            GitCommitInfo or None if failed
        """
        try:
            # Create branch if requested
            if branch_name:
                self._create_branch(branch_name)
            
            # Stage files
            for file_path in updated_files:
                self._git_add(file_path)
            
            # Generate commit message
            commit_message = self._generate_commit_message(healing_details)
            
            # Commit
            commit_hash = self._git_commit(commit_message)
            
            return GitCommitInfo(
                commit_hash=commit_hash,
                timestamp=datetime.now(),
                files_changed=updated_files,
                selectors_healed=len(healing_details),
                message=commit_message
            )
        
        except Exception as e:
            print(f"Git commit failed: {e}")
            return None
    
    def _create_branch(self, branch_name: str):
        """Create and checkout new branch"""
        result = subprocess.run(
            ['git', 'checkout', '-b', branch_name],
            cwd=self.repo_path,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            # Branch might already exist, try to checkout
            subprocess.run(
                ['git', 'checkout', branch_name],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
    
    def _git_add(self, file_path: Path):
        """Stage file for commit"""
        relative_path = file_path.relative_to(self.repo_path)
        
        subprocess.run(
            ['git', 'add', str(relative_path)],
            cwd=self.repo_path,
            check=True
        )
    
    def _git_commit(self, message: str) -> str:
        """
        Commit staged changes
        
        Returns:
            Commit hash
        """
        # Commit
        subprocess.run(
            ['git', 'commit', '-m', message],
            cwd=self.repo_path,
            check=True,
            capture_output=True,
            text=True
        )
        
        # Get commit hash
        result = subprocess.run(
            ['git', 'rev-parse', 'HEAD'],
            cwd=self.repo_path,
            capture_output=True,
            text=True,
            check=True
        )
        
        return result.stdout.strip()
    
    def _generate_commit_message(self, healing_details: List[dict]) -> str:
        """Generate detailed commit message"""
        lines = [
            "Auto-heal: Fixed broken selectors",
            "",
            f"Healed {len(healing_details)} selector(s) automatically:",
            ""
        ]
        
        for i, detail in enumerate(healing_details, 1):
            lines.append(f"{i}. {detail['element_name']}")
            lines.append(f"   File: {detail['file_path']}")
            lines.append(f"   Old: {detail['old_selector']}")
            lines.append(f"   New: {detail['new_selector']}")
            lines.append(f"   Confidence: {detail['confidence']:.2f}")
            lines.append(f"   Strategy: {detail['strategy']}")
            lines.append("")
        
        lines.append("Generated by Mobile Test Recorder healing system")
        lines.append(f"Timestamp: {datetime.now().isoformat()}")
        
        return "\n".join(lines)
    
    def create_diff_report(
        self,
        updated_files: List[Path]
    ) -> str:
        """
        Generate diff report for updated files
        
        Args:
            updated_files: List of updated files
        
        Returns:
            Formatted diff output
        """
        try:
            all_diffs = []
            
            for file_path in updated_files:
                relative_path = file_path.relative_to(self.repo_path)
                
                result = subprocess.run(
                    ['git', 'diff', str(relative_path)],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True
                )
                
                if result.stdout:
                    all_diffs.append(f"\n{'=' * 80}\n")
                    all_diffs.append(f"File: {relative_path}\n")
                    all_diffs.append(f"{'=' * 80}\n")
                    all_diffs.append(result.stdout)
            
            return "".join(all_diffs) if all_diffs else "No changes detected"
        
        except Exception as e:
            return f"Error generating diff: {e}"
    
    def revert_commit(self, commit_hash: str) -> bool:
        """
        Revert a healing commit
        
        Args:
            commit_hash: Commit to revert
        
        Returns:
            True if successful
        """
        try:
            subprocess.run(
                ['git', 'revert', '--no-edit', commit_hash],
                cwd=self.repo_path,
                check=True,
                capture_output=True
            )
            return True
        
        except Exception as e:
            print(f"Revert failed: {e}")
            return False
    
    def get_healing_history(
        self,
        limit: int = 10
    ) -> List[GitCommitInfo]:
        """
        Get history of healing commits
        
        Args:
            limit: Maximum number of commits to return
        
        Returns:
            List of healing commits
        """
        try:
            result = subprocess.run(
                ['git', 'log', '--grep=Auto-heal', f'-{limit}', '--format=%H|%aI|%s'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            
            commits = []
            for line in result.stdout.strip().split('\n'):
                if not line:
                    continue
                
                parts = line.split('|', 2)
                if len(parts) == 3:
                    commit_hash, timestamp_str, message = parts
                    
                    # Get files changed
                    files_result = subprocess.run(
                        ['git', 'show', '--name-only', '--format=', commit_hash],
                        cwd=self.repo_path,
                        capture_output=True,
                        text=True
                    )
                    
                    files = [
                        self.repo_path / f
                        for f in files_result.stdout.strip().split('\n')
                        if f
                    ]
                    
                    commits.append(GitCommitInfo(
                        commit_hash=commit_hash,
                        timestamp=datetime.fromisoformat(timestamp_str),
                        files_changed=files,
                        selectors_healed=len(files),
                        message=message
                    ))
            
            return commits
        
        except Exception as e:
            print(f"Error getting history: {e}")
            return []
    
    def is_repo_clean(self) -> bool:
        """Check if repository has no uncommitted changes"""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            
            return len(result.stdout.strip()) == 0
        
        except Exception:
            return False
    
    def save_healing_metadata(
        self,
        healing_details: List[dict],
        output_path: Optional[Path] = None
    ):
        """
        Save healing metadata to JSON file
        
        Args:
            healing_details: List of healing details
            output_path: Where to save (defaults to repo/.healing_metadata.json)
        """
        if output_path is None:
            output_path = self.repo_path / '.healing_metadata.json'
        
        # Load existing metadata
        metadata = []
        if output_path.exists():
            try:
                metadata = json.loads(output_path.read_text())
            except Exception:
                metadata = []
        
        # Add new entries
        for detail in healing_details:
            metadata.append({
                'timestamp': datetime.now().isoformat(),
                'file': str(detail['file_path']),
                'element': detail['element_name'],
                'old_selector': detail['old_selector'],
                'new_selector': detail['new_selector'],
                'confidence': detail['confidence'],
                'strategy': detail['strategy'],
            })
        
        # Save
        output_path.write_text(json.dumps(metadata, indent=2))

